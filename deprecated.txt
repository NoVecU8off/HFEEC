    /// Тип функции-обработчика для полученных пакетов (устарел)
    pub type PacketHandler = Box<dyn Fn(&PacketData) + Send + 'static>;

    pub fn start_packet_processing(&mut self, handler: PacketHandler) -> Result<(), DpdkError> {
        if !self.initialized {
            return Err(DpdkError::NotInitialized);
        }

        let port_id: u16 = self.config.port_id;
        let burst_size: u32 = self.config.burst_size;
        let running: Arc<AtomicBool> = self.running.clone();
        let num_queues: u16 = self.config.num_rx_queues;
        let use_affinity: bool = self.config.use_cpu_affinity;

        // Устанавливаем флаг, что мы работаем
        running.store(true, Ordering::SeqCst);

        // Получаем список доступных ядер процессора для привязки потоков
        // Используем Arc для возможности безопасного совместного использования в разных потоках
        let core_ids = Arc::new(if use_affinity {
            core_affinity::get_core_ids().unwrap_or_default()
        } else {
            Vec::new()
        });

        // Создаем канал для передачи данных пакетов
        let (tx, rx) = std::sync::mpsc::channel();

        // Создаем отдельный поток для каждой очереди
        for queue_id in 0..num_queues {
            let tx_clone: std::sync::mpsc::Sender<PacketData<'_>> = tx.clone();
            let running_clone: Arc<AtomicBool> = running.clone();
            let core_ids_clone: Arc<Vec<core_affinity::CoreId>> = core_ids.clone();

            // Создаем поток для очереди queue_id
            let thread_handle: JoinHandle<()> = std::thread::spawn(move || {
                // Привязка потока к ядру, если требуется и есть доступные ядра
                if use_affinity && !core_ids_clone.is_empty() {
                    let core_index: usize = (queue_id as usize) % core_ids_clone.len();
                    if let Some(core_id) = core_ids_clone.get(core_index) {
                        core_affinity::set_for_current(core_id.clone());
                    }
                }

                // Буфер для указателей на пакеты
                let mut rx_pkts: Vec<*mut RteMbuf> = vec![ptr::null_mut(); burst_size as usize];

                // Буферы для извлечения данных из пакетов
                let src_ip_buf: Vec<u8> = vec![0u8; 64]; // Буфер для source IP
                let dst_ip_buf: Vec<u8> = vec![0u8; 64]; // Буфер для destination IP

                while running_clone.load(Ordering::SeqCst) {
                    // Получаем пакеты из этой очереди
                    let nb_rx: u16 = unsafe {
                        rte_eth_rx_burst(
                            port_id,
                            queue_id, // Используем ID текущей очереди
                            rx_pkts.as_mut_ptr(),
                            burst_size as c_ushort,
                        )
                    };

                    // Обрабатываем каждый полученный пакет
                    for i in 0..nb_rx as usize {
                        let pkt: *mut RteMbuf = rx_pkts[i];

                        // Извлекаем информацию о пакете через нашу вспомогательную C-функцию
                        let src_ip_ptr: *mut i8 = src_ip_buf.as_ptr() as *mut c_char;
                        let dst_ip_ptr: *mut i8 = dst_ip_buf.as_ptr() as *mut c_char;
                        let mut src_port: c_ushort = 0;
                        let mut dst_port: c_ushort = 0;
                        let mut data_ptr: *mut u8 = ptr::null_mut();
                        let mut data_len: c_uint = 0;

                        let ret: i32 = unsafe {
                            dpdk_extract_packet_data(
                                pkt,
                                src_ip_ptr,
                                dst_ip_ptr,
                                &mut src_port,
                                &mut dst_port,
                                &mut data_ptr,
                                &mut data_len,
                            )
                        };

                        // Если успешно извлекли данные из пакета
                        if ret == 0 && !data_ptr.is_null() && data_len > 0 {
                            let src_ip: Cow<'_, str> =
                                unsafe { CStr::from_ptr(src_ip_ptr) }.to_string_lossy();
                            let dst_ip: Cow<'_, str> =
                                unsafe { CStr::from_ptr(dst_ip_ptr) }.to_string_lossy();

                            // Копируем данные пакета в Rust-вектор
                            let data: &[u8] =
                                unsafe { slice::from_raw_parts(data_ptr, data_len as usize) };

                            // Создаем структуру данных пакета (добавляем queue_id)
                            let packet_data: PacketData<'_> = PacketData {
                                source_ip: src_ip,
                                dest_ip: dst_ip,
                                source_port: src_port,
                                dest_port: dst_port,
                                data,
                                queue_id: queue_id,
                            };

                            // Отправляем данные через канал
                            let _ = tx_clone.send(packet_data);
                        }

                        // Освобождаем память пакета после обработки
                        unsafe { rte_pktmbuf_free(pkt) };
                    }
                }
            });

            // Сохраняем handle потока
            self.worker_threads.push(thread_handle);
        }

        // Поток для обработки данных пакетов
        let handler_thread: JoinHandle<()> = std::thread::spawn(move || {
            while let Ok(packet_data) = rx.recv() {
                if !running.load(Ordering::SeqCst) {
                    break;
                }

                // Вызываем обработчик
                handler(&packet_data);
            }
        });

        // Сохраняем handle потока обработчика
        self.worker_threads.push(handler_thread);

        Ok(())
    }
